#!/usr/bin/env python3
"""
Game Mod Launcher

A standalone launcher for installing and playing modded games.
Auto-generated by Game Mod Builder.
"""

import os
import sys
import json
import sqlite3
import hashlib
import zipfile
import tempfile
import logging
import subprocess
import urllib.request
from datetime import datetime
from pathlib import Path

from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QPushButton, QProgressBar, QMessageBox, QFileDialog,
    QGroupBox, QListWidget, QListWidgetItem, QStatusBar, QDialog,
    QTextBrowser, QFrame, QTextEdit, QSplitter
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer, QObject
from PyQt5.QtGui import QIcon, QFont, QTextCursor

from src.models.constants import APP_NAME


# Load configuration
def load_config():
    """
    Load launcher configuration from external file or embedded resource.

    Returns:
        dict: Configuration dictionary
    """
    logger = logging.getLogger(__name__)
    config_file = "launcher_config.json"

    # Check if running as bundled executable
    if getattr(sys, 'frozen', False):
        # Check for config next to the executable first
        exe_dir = os.path.dirname(sys.executable)
        config_path = os.path.join(exe_dir, config_file)

        if os.path.exists(config_path):
            logger.info(f"Loading configuration from: {config_path}")
            try:
                with open(config_path, 'r') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Error loading external config: {e}")

        # Try to load from embedded resource
        try:
            # Get the path to the embedded resource
            if hasattr(sys, '_MEIPASS'):
                resource_path = os.path.join(sys._MEIPASS, config_file)
                if os.path.exists(resource_path):
                    logger.info(f"Loading embedded configuration from: {resource_path}")
                    with open(resource_path, 'r') as f:
                        return json.load(f)
        except Exception as e:
            logger.error(f"Error loading embedded config: {e}")
    else:
        # In development mode, check current directory
        if os.path.exists(config_file):
            logger.info(f"Loading development configuration from: {config_file}")
            try:
                with open(config_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Error loading development config: {e}")

    # Fallback to default configuration
    logger.warning("Using default configuration")
    return {
        "name": "Default Game Mod Launcher",
        "description": "Default configuration - please provide a valid config file",
        "game_exe": "game.exe",
        "mods": [],
        "validation_files": ["game.exe"],
        "default_locations": [],
        "version": "1.0.0"
    }


# Load the configuration
CONFIG = load_config()


# Get OS-specific app data directory
def get_app_data_dir():
    """
    Get OS-specific application data directory.

    Returns:
        Path: Path to app data directory
    """
    app_name = CONFIG['name'].replace(' ', '')

    if sys.platform == 'win32':
        # Windows
        app_data = os.environ.get('APPDATA', '')
        base_dir = Path(app_data) / app_name
    elif sys.platform == 'darwin':
        # macOS
        base_dir = Path.home() / 'Library' / 'Application Support' / app_name
    else:
        # Linux and others
        base_dir = Path.home() / '.local' / 'share' / app_name.lower()

    # Create directory if it doesn't exist
    base_dir.mkdir(parents=True, exist_ok=True)

    return base_dir


# App data directory
APP_DATA_DIR = get_app_data_dir()

# Database file for tracking installed mods
DB_PATH = APP_DATA_DIR / "mods.db"

# Settings file
SETTINGS_PATH = APP_DATA_DIR / "settings.json"


# Create a QT-based logging handler
class QTextEditLogger(QObject, logging.Handler):
    """Custom logging handler that emits log records to a QTextEdit widget."""

    log_message = pyqtSignal(str)

    def __init__(self, text_widget):
        """
        Initialize the handler.

        Args:
            text_widget: QTextEdit widget to receive log messages
        """
        super().__init__()
        self.text_widget = text_widget
        self.log_message.connect(self.append_text)

        # Set a formatter for the handler
        formatter = logging.Formatter('[%(asctime)s][%(levelname)s] - %(message)s')
        self.setFormatter(formatter)

    def emit(self, record):
        """
        Emit a log record.

        Args:
            record: Log record to emit
        """
        # Format the log message
        log_entry = self.format(record)

        # Add color based on log level
        if record.levelno >= logging.ERROR:
            log_entry = f'<span style="color: red;">{log_entry}</span>'
        elif record.levelno >= logging.WARNING:
            log_entry = f'<span style="color: orange;">{log_entry}</span>'
        elif record.levelno >= logging.INFO:
            log_entry = f'<span style="color: black;">{log_entry}</span>'
        else:  # DEBUG
            log_entry = f'<span style="color: gray;">{log_entry}</span>'

        # Emit the signal with the formatted message
        self.log_message.emit(log_entry)

    def append_text(self, text):
        """
        Append text to the QTextEdit.

        Args:
            text: Text to append
        """
        self.text_widget.append(text)
        # Ensure the most recent log entry is visible
        cursor = self.text_widget.textCursor()
        cursor.movePosition(QTextCursor.End)
        self.text_widget.setTextCursor(cursor)


# Set up logging
def setup_logging(log_widget):
    """
    Set up logging configuration to output logs to a widget.

    Args:
        log_widget: QTextEdit widget for log display

    Returns:
        logging.Logger: Configured logger
    """
    # Get the root logger
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)

    # Remove any existing handlers to avoid duplicates
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    # Add our custom handler for the widget
    qt_handler = QTextEditLogger(log_widget)
    logger.addHandler(qt_handler)

    # Get the main logger for this module
    module_logger = logging.getLogger(__name__)
    module_logger.info(f"Starting {CONFIG['name']} v{CONFIG.get('version', '1.0.0')}")
    module_logger.info(f"Using app data directory: {APP_DATA_DIR}")

    return module_logger


class AboutDialog(QDialog):
    """About dialog showing information about the launcher."""

    def __init__(self, parent=None):
        """
        Initialize the about dialog.

        Args:
            parent: Parent widget
        """
        super().__init__(parent)
        self.setWindowTitle("About")
        self.setFixedSize(400, 300)

        layout = QVBoxLayout(self)

        # Title
        title = QLabel(CONFIG["name"])
        title.setFont(QFont("Arial", 16, QFont.Bold))
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)

        # Version
        version = QLabel(f"Version {CONFIG.get('version', '1.0.0')}")
        version.setAlignment(Qt.AlignCenter)
        layout.addWidget(version)

        # Description
        if CONFIG.get("description"):
            desc = QLabel(CONFIG["description"])
            desc.setWordWrap(True)
            desc.setAlignment(Qt.AlignCenter)
            layout.addWidget(desc)

        # Information
        info = QTextBrowser()
        info.setHtml(f"""
        <p><b>Mods:</b></p>
        <ul>
        {"".join(f"<li>{mod['name']}</li>" for mod in CONFIG.get("mods", []))}
        </ul>
        <p>Created with {APP_NAME}</p>
        """)
        layout.addWidget(info)

        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.accept)
        layout.addWidget(close_btn)


class DownloadThread(QThread):
    """Thread for downloading files."""

    progress_updated = pyqtSignal(str, int)
    download_completed = pyqtSignal(bool, str, str)

    def __init__(self, url, target_file):
        """
        Initialize the download thread.

        Args:
            url: URL to download from
            target_file: Path to save the downloaded file
        """
        super().__init__()
        self.url = url
        self.target_file = target_file
        self.logger = logging.getLogger(__name__)

    def run(self):
        """Run the download thread."""
        try:
            self.progress_updated.emit("Connecting to server...", 0)
            self.logger.info(f"Starting download from: {self.url}")

            # Create temporary file for download
            temp_file = f"{self.target_file}.download"
            self.logger.debug(f"Using temporary file: {temp_file}")

            # Download the file
            urllib.request.urlretrieve(
                self.url,
                temp_file,
                self.update_progress
            )

            # Rename temporary file to target file
            if os.path.exists(self.target_file):
                self.logger.info(f"Removing existing file: {self.target_file}")
                os.remove(self.target_file)
            os.rename(temp_file, self.target_file)
            self.logger.info(f"Download completed: {self.target_file}")

            self.progress_updated.emit("Download complete", 100)
            self.download_completed.emit(True, self.target_file, "")

        except Exception as e:
            self.logger.error(f"Download failed: {self.url} {str(e)}")
            self.progress_updated.emit(f"Error: {str(e)}", 0)
            self.download_completed.emit(False, "", str(e))

    def update_progress(self, block_num, block_size, total_size):
        """
        Update download progress.

        Args:
            block_num: Current block number
            block_size: Block size
            total_size: Total file size
        """
        if total_size > 0:
            percent = min(100, int(block_num * block_size * 100 / total_size))
            downloaded = block_num * block_size
            if downloaded % (1024 * 1024) < block_size:  # Log every 1MB
                self.logger.debug(
                    f"Downloaded {downloaded / (1024 * 1024):.1f} MB of {total_size / (1024 * 1024):.1f} MB ({percent}%)")
            self.progress_updated.emit(f"Downloading... {percent}%", percent)
        else:
            # If total size is unknown, use indeterminate progress
            self.progress_updated.emit("Downloading...", -1)


class ModInstallThread(QThread):
    """Thread for installing mods."""

    progress_updated = pyqtSignal(str, int)
    installation_completed = pyqtSignal(bool, str)

    def __init__(self, mod, game_dir):
        """
        Initialize the mod installation thread.

        Args:
            mod: Mod configuration
            game_dir: Game directory path
        """
        super().__init__()
        self.mod = mod
        self.game_dir = game_dir
        self.temp_dir = tempfile.gettempdir()
        self.logger = logging.getLogger(__name__)

    def run(self):
        """Run the installation thread."""
        try:
            # Prepare file paths
            mod_name = self.mod["name"]
            zip_path = os.path.join(self.temp_dir, f"{mod_name.replace(' ', '_')}.zip")

            self.logger.info(f"Starting installation of mod: {mod_name}")
            self.logger.info(f"Game directory: {self.game_dir}")
            self.logger.info(f"Temp download path: {zip_path}")

            self.progress_updated.emit(f"Downloading {mod_name}...", 10)

            # Create download thread
            self.download_thread = DownloadThread(self.mod["download_url"], zip_path)
            self.download_thread.progress_updated.connect(
                lambda msg, progress: self.progress_updated.emit(msg, min(10 + int(progress * 0.6), 70))
            )

            # Set up signal handlers for download completion
            self.download_thread.download_completed.connect(self.handle_download_completed)

            # Start download
            self.download_thread.start()
            self.download_thread.wait()  # Wait for download to complete

        except Exception as e:
            self.logger.error(f"Installation failed: {str(e)}")
            self.progress_updated.emit(f"Error: {str(e)}", 0)
            self.installation_completed.emit(False, str(e))

    def handle_download_completed(self, success, file_path, error):
        """
        Handle download completion.

        Args:
            success: Whether the download was successful
            file_path: Path to the downloaded file
            error: Error message if download failed
        """
        if not success:
            self.logger.error(f"Download failed: {error}")
            self.installation_completed.emit(False, f"Download failed: {file_path} {error}")
            return

        try:
            # Extract the zip
            mod_name = self.mod["name"]
            target_dir = os.path.join(self.game_dir, self.mod["target_path"])

            self.logger.info(f"Starting extraction to: {target_dir}")
            self.progress_updated.emit(f"Installing {mod_name}...", 75)

            # Ensure target directory exists
            if not os.path.exists(target_dir):
                self.logger.info(f"Creating target directory: {target_dir}")
                os.makedirs(target_dir, exist_ok=True)

            # Extract the zip file
            file_count = 0
            with zipfile.ZipFile(file_path, 'r') as zip_ref:
                file_list = zip_ref.namelist()
                file_count = len(file_list)
                self.logger.info(f"Extracting {file_count} files")
                zip_ref.extractall(target_dir)

            self.logger.info(f"Extraction complete - {file_count} files extracted")

            # Calculate and store file hash
            file_hash = self.calculate_file_hash(file_path)
            self.logger.debug(f"Mod file hash: {file_hash}")

            # Clean up
            try:
                self.logger.info(f"Removing temporary file: {file_path}")
                os.remove(file_path)
            except Exception as e:
                self.logger.warning(f"Failed to remove temporary file: {e}")

            # Update database
            self.update_mod_database(mod_name, file_hash)

            self.logger.info(f"Mod {mod_name} installed successfully")
            self.progress_updated.emit(f"{mod_name} installed successfully", 100)
            self.installation_completed.emit(True, "")

        except Exception as e:
            self.logger.error(f"Extraction failed: {str(e)}")
            self.progress_updated.emit(f"Error: {str(e)}", 0)
            self.installation_completed.emit(False, str(e))

    def calculate_file_hash(self, file_path):
        """
        Calculate SHA-256 hash of a file.

        Args:
            file_path: Path to the file

        Returns:
            str: Hex digest of the hash
        """
        self.logger.debug(f"Calculating hash for file: {file_path}")
        hasher = hashlib.sha256()
        with open(file_path, 'rb') as f:
            buf = f.read(65536)
            while len(buf) > 0:
                hasher.update(buf)
                buf = f.read(65536)
        return hasher.hexdigest()

    def update_mod_database(self, mod_name, file_hash):
        """
        Update the mod installation database.

        Args:
            mod_name: Name of the mod
            file_hash: Hash of the mod file
        """
        self.logger.info(f"Updating mod database for: {mod_name}")
        conn = sqlite3.connect(str(DB_PATH))
        cursor = conn.cursor()

        # Create table if it doesn't exist
        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS installed_mods
                       (
                           name
                           TEXT
                           PRIMARY
                           KEY,
                           hash
                           TEXT,
                           install_date
                           TEXT
                       )
                       ''')

        # Insert or update mod entry
        install_date = datetime.now().isoformat()
        cursor.execute(
            "INSERT OR REPLACE INTO installed_mods VALUES (?, ?, ?)",
            (mod_name, file_hash, install_date)
        )

        conn.commit()
        conn.close()
        self.logger.info(f"Mod database updated for: {mod_name} (installed: {install_date})")


class LauncherWindow(QMainWindow):
    """Main launcher window."""

    def __init__(self):
        """Initialize the launcher window."""
        super().__init__()
        self.setWindowTitle(CONFIG["name"])
        self.setMinimumSize(600, 500)

        # Create the log widget first
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setLineWrapMode(QTextEdit.NoWrap)

        # Initialize logger with the log widget
        self.logger = setup_logging(self.log_text)

        # Initialize database if needed
        self.init_database()

        # Set up the UI
        self.setup_ui()

        # Get last saved game directory
        self.game_dir = self.load_settings().get("game_dir", None)

        # Update UI based on game directory
        self.update_game_path_ui()

        # Auto-detect game directory if not set
        if not self.game_dir:
            QTimer.singleShot(500, self.detect_game_directory)

    def init_database(self):
        """Initialize the SQLite database for tracking installed mods."""
        self.logger.info(f"Initializing database at: {DB_PATH}")
        conn = sqlite3.connect(str(DB_PATH))
        cursor = conn.cursor()

        cursor.execute('''
                       CREATE TABLE IF NOT EXISTS installed_mods
                       (
                           name
                           TEXT
                           PRIMARY
                           KEY,
                           hash
                           TEXT,
                           install_date
                           TEXT
                       )
                       ''')

        conn.commit()
        conn.close()
        self.logger.info("Database initialization complete")

    def setup_ui(self):
        """Set up the user interface."""
        # Main widget
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Create a splitter to divide main content and log
        self.splitter = QSplitter(Qt.Vertical)

        # Top part (main UI)
        top_widget = QWidget()
        top_layout = QVBoxLayout(top_widget)
        top_layout.setContentsMargins(0, 0, 0, 0)

        # Header section
        header = QFrame()
        header_layout = QHBoxLayout(header)
        header_layout.setContentsMargins(0, 0, 0, 10)

        # Title
        title = QLabel(CONFIG["name"])
        title.setFont(QFont("Arial", 16, QFont.Bold))
        header_layout.addWidget(title)

        # Buttons
        header_buttons = QHBoxLayout()

        # Log toggle button
        self.log_button = QPushButton("Show Log")
        self.log_button.setCheckable(True)
        self.log_button.clicked.connect(self.toggle_log_panel)
        header_buttons.addWidget(self.log_button)

        # About button
        about_btn = QPushButton("About")
        about_btn.setFixedWidth(80)
        about_btn.clicked.connect(self.show_about)
        header_buttons.addWidget(about_btn)

        header_layout.addLayout(header_buttons)

        top_layout.addWidget(header)

        # Description
        if CONFIG.get("description"):
            desc_label = QLabel(CONFIG["description"])
            desc_label.setWordWrap(True)
            desc_label.setStyleSheet("color: #666; margin-bottom: 10px;")
            top_layout.addWidget(desc_label)

        # Game path section
        self.path_group = QGroupBox("Game Location")
        path_layout = QVBoxLayout(self.path_group)

        self.path_label = QLabel("No game directory selected")
        path_layout.addWidget(self.path_label)

        self.select_dir_btn = QPushButton("Select Game Directory")
        self.select_dir_btn.clicked.connect(self.browse_game_directory)
        path_layout.addWidget(self.select_dir_btn)

        top_layout.addWidget(self.path_group)

        # Mods section
        mods_group = QGroupBox("Mods")
        mods_layout = QVBoxLayout(mods_group)

        self.mods_list = QListWidget()
        self.update_mods_list()
        mods_layout.addWidget(self.mods_list)

        top_layout.addWidget(mods_group)

        # Progress section
        self.progress_group = QGroupBox("Progress")
        self.progress_group.setVisible(False)
        progress_layout = QVBoxLayout(self.progress_group)

        self.progress_bar = QProgressBar()
        progress_layout.addWidget(self.progress_bar)

        self.progress_label = QLabel("Preparing...")
        progress_layout.addWidget(self.progress_label)

        top_layout.addWidget(self.progress_group)

        # Buttons section
        buttons_layout = QHBoxLayout()

        self.update_btn = QPushButton("Update/Install Mods")
        self.update_btn.clicked.connect(self.update_mods)
        buttons_layout.addWidget(self.update_btn)

        self.play_btn = QPushButton("Play Game")
        self.play_btn.clicked.connect(self.launch_game)
        buttons_layout.addWidget(self.play_btn)

        top_layout.addLayout(buttons_layout)

        # Add the top widget to the splitter
        self.splitter.addWidget(top_widget)

        # Bottom part (log panel)
        log_widget = QWidget()
        log_layout = QVBoxLayout(log_widget)
        log_layout.setContentsMargins(0, 0, 0, 0)

        # Log controls
        log_controls = QHBoxLayout()

        log_title = QLabel("Log")
        log_title.setFont(QFont("Arial", 10, QFont.Bold))
        log_controls.addWidget(log_title)

        log_controls.addStretch()

        # Clear log button
        clear_log_btn = QPushButton("Clear Log")
        clear_log_btn.clicked.connect(self.clear_log)
        log_controls.addWidget(clear_log_btn)

        # Save log button
        save_log_btn = QPushButton("Save Log")
        save_log_btn.clicked.connect(self.save_log)
        log_controls.addWidget(save_log_btn)

        log_layout.addLayout(log_controls)

        # Log text area (already created)
        log_layout.addWidget(self.log_text)

        # Add the log widget to the splitter
        self.splitter.addWidget(log_widget)

        # Set initial sizes
        self.splitter.setSizes([500, 0])  # Hide log panel by default

        # Add the splitter to the main layout
        main_layout.addWidget(self.splitter)

        # Set the central widget
        self.setCentralWidget(main_widget)

        # Status bar
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("Ready")

    def toggle_log_panel(self, checked):
        """
        Show or hide the log panel.

        Args:
            checked: Whether the button is checked
        """
        if checked:
            self.log_button.setText("Hide Log")
            sizes = self.splitter.sizes()
            if sizes[1] == 0:
                # Show log panel
                self.splitter.setSizes([int(self.height() * 0.6), int(self.height() * 0.4)])
        else:
            self.log_button.setText("Show Log")
            # Hide log panel
            self.splitter.setSizes([self.height(), 0])

    def clear_log(self):
        """Clear the log text widget."""
        self.log_text.clear()

    def save_log(self):
        """Save the current log content to a file."""
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Save Log File",
            os.path.join(os.path.expanduser("~"), "launcher_log.txt"),
            "Text Files (*.txt);;All Files (*)"
        )

        if file_path:
            try:
                with open(file_path, 'w') as f:
                    f.write(self.log_text.toPlainText())
                self.logger.info(f"Log saved to: {file_path}")
                self.status_bar.showMessage(f"Log saved to: {file_path}", 3000)
            except Exception as e:
                self.logger.error(f"Failed to save log: {e}")
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to save log: {str(e)}"
                )

    def update_mods_list(self):
        """Update the mods list with installation status."""
        self.logger.debug("Updating mods list")
        self.mods_list.clear()

        if not CONFIG.get("mods"):
            self.mods_list.addItem("No mods configured")
            return

        # Get installed mods from database
        installed_mods = self.get_installed_mods()

        for mod in CONFIG["mods"]:
            item = QListWidgetItem()
            mod_name = mod["name"]

            if mod_name in installed_mods:
                item.setText(f"{mod_name} - Installed")
                # Set icon (could use actual icon files in a real app)
                item.setIcon(QIcon.fromTheme("dialog-ok"))
                self.logger.debug(f"Mod '{mod_name}' is installed")
            else:
                item.setText(f"{mod_name} - Not Installed")
                item.setIcon(QIcon.fromTheme("dialog-error"))
                self.logger.debug(f"Mod '{mod_name}' is not installed")

            self.mods_list.addItem(item)

    def get_installed_mods(self):
        """
        Get a list of installed mods from the database.

        Returns:
            list: List of installed mod names
        """
        installed = []

        conn = sqlite3.connect(str(DB_PATH))
        cursor = conn.cursor()

        try:
            cursor.execute("SELECT name FROM installed_mods")
            installed = [row[0] for row in cursor.fetchall()]
            self.logger.debug(f"Found {len(installed)} installed mods in database")
        except sqlite3.OperationalError as e:
            self.logger.warning(f"Error querying installed mods: {e}")
        finally:
            conn.close()

        return installed

    def load_settings(self):
        """
        Load settings from the settings file.

        Returns:
            dict: Settings dictionary
        """
        self.logger.debug(f"Loading settings from: {SETTINGS_PATH}")
        if SETTINGS_PATH.exists():
            try:
                with open(SETTINGS_PATH, 'r') as f:
                    settings = json.load(f)
                    self.logger.debug(f"Settings loaded: {settings}")
                    return settings
            except Exception as e:
                self.logger.error(f"Failed to load settings: {e}")
        return {}

    def save_settings(self, settings):
        """
        Save settings to the settings file.

        Args:
            settings: Settings dictionary
        """
        self.logger.debug(f"Saving settings: {settings}")
        try:
            with open(SETTINGS_PATH, 'w') as f:
                json.dump(settings, f, indent=2)
            self.logger.debug(f"Settings saved to: {SETTINGS_PATH}")
        except Exception as e:
            self.logger.error(f"Error saving settings: {e}")

    def detect_game_directory(self):
        """Try to auto-detect the game directory."""
        self.logger.info("Auto-detecting game directory")
        # First check last saved path
        if self.game_dir and self.validate_game_directory(self.game_dir):
            self.logger.info(f"Using saved game directory: {self.game_dir}")
            return True

        # Then check default locations from config
        for location in CONFIG.get("default_locations", []):
            self.logger.debug(f"Checking location: {location}")
            if os.path.exists(location) and self.validate_game_directory(location):
                self.game_dir = location
                self.save_settings({"game_dir": location})
                self.update_game_path_ui()
                self.logger.info(f"Found game directory in default locations: {location}")
                return True

        # If running on Windows, check common game directories
        if sys.platform == "win32":
            self.logger.debug("Running on Windows, checking common game directories")
            drives = ['C:', 'D:', 'E:', 'F:']
            common_paths = [
                               os.path.join(drive, "Program Files", "Steam", "steamapps", "common") for drive in drives
                           ] + [
                               os.path.join(drive, "Program Files (x86)", "Steam", "steamapps", "common") for drive in
                               drives
                           ] + [
                               os.path.join(drive, "Games") for drive in drives
                           ] + [
                               os.path.join(drive, "Epic Games") for drive in drives
                           ]

            for path in common_paths:
                if os.path.exists(path):
                    self.logger.debug(f"Checking common path: {path}")
                    # Check subdirectories for game
                    try:
                        for subdir in os.listdir(path):
                            full_path = os.path.join(path, subdir)
                            if os.path.isdir(full_path) and self.validate_game_directory(full_path):
                                self.game_dir = full_path
                                self.save_settings({"game_dir": full_path})
                                self.update_game_path_ui()
                                self.logger.info(f"Found game directory in common locations: {full_path}")
                                return True
                    except Exception as e:
                        self.logger.debug(f"Error checking path {path}: {e}")

        self.logger.info("Game directory not found automatically")
        return False

    def validate_game_directory(self, directory):
        """
        Check if the directory contains the required game files.

        Args:
            directory: Path to the directory

        Returns:
            bool: True if directory is valid
        """
        self.logger.debug(f"Validating game directory: {directory}")
        for file_path in CONFIG.get("validation_files", []):
            full_path = os.path.join(directory, file_path)
            if not os.path.exists(full_path):
                self.logger.debug(f"Validation file not found: {full_path}")
                return False
            self.logger.debug(f"Validation file found: {full_path}")
        return True

    def update_game_path_ui(self):
        """Update UI elements based on game directory status."""
        if self.game_dir and self.validate_game_directory(self.game_dir):
            self.logger.debug(f"Valid game directory: {self.game_dir}")
            self.path_label.setText(f"Game directory: {self.game_dir}")
            self.path_label.setStyleSheet("color: green;")
            self.update_btn.setEnabled(True)

            # Enable play button if all mods are installed
            self.play_btn.setEnabled(self.all_mods_installed())
        else:
            self.logger.debug("No valid game directory")
            self.path_label.setText("No valid game directory selected")
            self.path_label.setStyleSheet("color: red;")
            self.update_btn.setEnabled(False)
            self.play_btn.setEnabled(False)
            self.game_dir = None

    def browse_game_directory(self):
        """Open file dialog to select game directory."""
        self.logger.info("Opening game directory selection dialog")
        directory = QFileDialog.getExistingDirectory(
            self, "Select Game Directory", "", QFileDialog.ShowDirsOnly
        )

        if directory:
            self.logger.info(f"User selected directory: {directory}")
            if self.validate_game_directory(directory):
                self.game_dir = directory
                self.save_settings({"game_dir": directory})
                self.update_game_path_ui()
                self.status_bar.showMessage("Game directory selected successfully", 3000)
                self.logger.info(f"Valid game directory selected: {directory}")
            else:
                self.logger.warning(f"Invalid game directory selected: {directory}")
                QMessageBox.warning(
                    self,
                    "Invalid Directory",
                    "The selected directory does not appear to contain the game. "
                    "Please select the correct directory."
                )

    def update_mods(self):
        """Start the process of updating/installing mods."""
        if not self.game_dir:
            self.logger.warning("Attempted to update mods without valid game directory")
            return

        self.logger.info("Starting mod update/installation process")

        # Disable buttons during installation
        self.update_btn.setEnabled(False)
        self.play_btn.setEnabled(False)
        self.select_dir_btn.setEnabled(False)

        # Show progress UI
        self.progress_group.setVisible(True)
        self.progress_bar.setValue(0)
        self.progress_label.setText("Preparing to install mods...")

        # Get list of mods that need installation
        installed_mods = self.get_installed_mods()
        mods_to_install = [mod for mod in CONFIG["mods"] if mod["name"] not in installed_mods]

        if not mods_to_install:
            self.logger.info("All mods are already installed")
            # All mods are already installed, ask if user wants to reinstall
            reply = QMessageBox.question(
                self,
                "Reinstall Mods?",
                "All mods are already installed. Would you like to reinstall them?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                self.logger.info("User chose to reinstall all mods")
                mods_to_install = CONFIG["mods"]
            else:
                self.logger.info("User chose not to reinstall mods")
                self.update_btn.setEnabled(True)
                self.play_btn.setEnabled(True)
                self.select_dir_btn.setEnabled(True)
                self.progress_group.setVisible(False)
                return
        else:
            self.logger.info(f"Found {len(mods_to_install)} mods to install")

        # Install mods sequentially
        self.install_next_mod(mods_to_install, 0)

    def install_next_mod(self, mods, index):
        """
        Install the mod at the given index.

        Args:
            mods: List of mods to install
            index: Current mod index
        """
        if index >= len(mods):
            # All mods installed
            self.logger.info("All mods installed successfully")
            self.progress_label.setText("All mods installed successfully!")
            self.progress_bar.setValue(100)

            # Re-enable buttons
            self.update_btn.setEnabled(True)
            self.play_btn.setEnabled(True)
            self.select_dir_btn.setEnabled(True)

            # Update mods list
            self.update_mods_list()

            # Show success message
            QMessageBox.information(
                self,
                "Installation Complete",
                "All mods have been installed successfully!"
            )

            # Hide progress group after a delay
            QTimer.singleShot(2000, lambda: self.progress_group.setVisible(False))

            return

        # Get current mod to install
        mod = mods[index]
        self.logger.info(f"Installing mod {index + 1} of {len(mods)}: {mod['name']}")

        # Create and start installer thread
        self.installer = ModInstallThread(mod, self.game_dir)
        self.installer.progress_updated.connect(self.update_install_progress)
        self.installer.installation_completed.connect(
            lambda success, error: self.handle_install_completion(success, error, mods, index)
        )
        self.installer.start()

    def update_install_progress(self, message, progress):
        """
        Update the progress bar and label.

        Args:
            message: Progress message
            progress: Progress percentage
        """
        self.progress_label.setText(message)
        self.progress_bar.setValue(progress)
        self.status_bar.showMessage(message)

    def handle_install_completion(self, success, error, mods, index):
        """
        Handle completion of a mod installation.

        Args:
            success: Whether installation was successful
            error: Error message if installation failed
            mods: List of mods being installed
            index: Index of the current mod
        """
        if success:
            # Move to next mod
            self.install_next_mod(mods, index + 1)
        else:
            self.logger.error(f"Mod installation failed: {mods[index]['name']} - {error}")
            # Show error and stop installation
            QMessageBox.critical(
                self,
                "Installation Error",
                f"Error installing {mods[index]['name']}: {error}"
            )

            # Re-enable buttons
            self.update_btn.setEnabled(True)
            self.select_dir_btn.setEnabled(True)

            # Update play button state
            self.play_btn.setEnabled(self.all_mods_installed())

            # Update mods list
            self.update_mods_list()

    def all_mods_installed(self):
        """
        Check if all mods are installed.

        Returns:
            bool: True if all mods are installed
        """
        if not CONFIG.get("mods"):
            return True

        installed_mods = self.get_installed_mods()
        all_installed = all(mod["name"] in installed_mods for mod in CONFIG["mods"])

        self.logger.debug(f"All mods installed: {all_installed}")
        return all_installed

    def launch_game(self):
        """Launch the game executable."""
        if not self.game_dir:
            self.logger.warning("Attempted to launch game without valid game directory")
            return

        # Build path to game executable
        game_exe = os.path.join(self.game_dir, CONFIG["game_exe"])
        self.logger.info(f"Launching game: {game_exe}")

        if not os.path.exists(game_exe):
            self.logger.error(f"Game executable not found: {game_exe}")
            QMessageBox.critical(
                self,
                "Error",
                f"Game executable not found: {game_exe}"
            )
            return

        # Launch the game
        try:
            self.status_bar.showMessage("Launching game...")

            if sys.platform == "win32":
                # Use native Windows method to open the executable
                self.logger.info(f"Launching game on Windows: {game_exe}")
                os.startfile(game_exe)
            else:
                # Use subprocess for other platforms
                self.logger.info(f"Launching game with subprocess: {game_exe}")
                subprocess.Popen([game_exe])

            # Minimize the launcher
            self.showMinimized()
            self.logger.info("Game launched successfully")

        except Exception as e:
            self.logger.error(f"Error launching game: {e}")
            QMessageBox.critical(
                self,
                "Launch Error",
                f"Error launching game: {str(e)}"
            )

    def show_about(self):
        """Show the about dialog."""
        self.logger.info("Showing about dialog")
        dialog = AboutDialog(self)
        dialog.exec_()


if __name__ == "__main__":
    # Create and run the application
    app = QApplication(sys.argv)

    # Set up application styles
    app.setStyle("Fusion")

    # Set application name and version
    app.setApplicationName(CONFIG["name"])
    app.setApplicationVersion(CONFIG.get("version", "1.0.0"))

    # Create and show the main window
    window = LauncherWindow()
    window.show()

    # Start the application event loop
    sys.exit(app.exec_())